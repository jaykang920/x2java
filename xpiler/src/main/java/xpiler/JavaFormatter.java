// Copyright (c) 2016 Jae-jun Kang
// See the file LICENSE for details.

package xpiler;

import java.io.*;
import java.util.*;

class JavaFormatter implements Formatter {
    private static final String extension = ".java";
    private static final String description = "Java";

    public boolean format(Document doc, String outDir) {
        List<Definition> definitions = doc.getDefinitions();
        for (Definition def : definitions) {
            def.name = StringUtil.firstToUpper(def.name);
        }

        if (!Xpiler.getOptions().isForced()) {
            boolean flag = true;
            for (Definition def : definitions) {
                if (!isUpToDate(doc.inputPath, outDir, def)) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                return true;
            }
        }

        System.out.println(PathUtil.getFilename(doc.inputPath));

        boolean result = true;
        for (Definition def : definitions) {
            if (!format(doc, def, outDir)) {
                result = false;
            }
        }
        return result;
    }

    private boolean format(Document doc, Definition def, String outDir) {
        PrintStream out = null;
        try {
            String targetName = PathUtil.join(outDir, def.name + extension);
            File file = new File(targetName);
            out = new PrintStream(new FileOutputStream(file), true, "UTF-8");
            Context context = new Context();
            context.out = out;
            context.doc = doc;
            formatHeader(context);
            def.format(context);
        } catch (Exception e) {
            System.err.format("error: %s\n", e.getMessage());
            return false;
        } finally {
            try {
                out.close();
            } catch (Exception e) { }
        }
        return true;
    }

    private void formatHeader(Context context) {
        PrintStream o = context.out;
        o.println("// auto-generated by x2java xpiler");
        o.println();
        String namespace = context.doc.namespace;
        if (StringUtil.isNullOrEmpty(namespace) == false) {
            o.format("package %s;", namespace.replace('/', '.').toLowerCase());
            o.println();
            o.println();
        }
        o.println("import java.util.*;");
        o.println();
        o.println("import x2.*;");
        o.println();

        for (Reference reference : context.doc.getReferences()) {
            reference.format(context);
        }
        o.println();
    }

    public String getDescription() { return description; }

    private boolean isUpToDate(String path, String outDir, Definition def) {
        File source = new File(path);
        File target = new File(PathUtil.join(outDir, def.name + extension));
        return (target.exists() && target.lastModified() >= source.lastModified());
    }

    private static class Context extends FormatterContext {
        private static Map<String, String> nativeTypes;
        private static Map<String, String> typeNames;
        private static Map<String, String> defaultValues;

        private static final String tab = "    ";
        private int baseIndentation = 0;

        static {
            nativeTypes = new HashMap<String, String>();
            nativeTypes.put("bool", "boolean");
            nativeTypes.put("byte", "byte");
            nativeTypes.put("bytes", "byte[]");
            nativeTypes.put("int8", "byte");
            nativeTypes.put("int16", "short");
            nativeTypes.put("int32", "int");
            nativeTypes.put("int64", "long");
            nativeTypes.put("float32", "float");
            nativeTypes.put("float64", "double");
            nativeTypes.put("string", "String");
            nativeTypes.put("datetime", "Calendar");
            nativeTypes.put("list", "ArrayList");
            nativeTypes.put("map", "HashMap");

            typeNames = new HashMap<String, String>();
            typeNames.put("bool", "Boolean");
            typeNames.put("byte", "Byte");
            typeNames.put("bytes", "Bytes");
            typeNames.put("int8", "Byte");
            typeNames.put("int16", "Short");
            typeNames.put("int32", "Int");
            typeNames.put("int64", "Long");
            typeNames.put("float32", "Float");
            typeNames.put("float64", "Double");
            typeNames.put("string", "String");
            typeNames.put("datetime", "Calendar");

            defaultValues = new HashMap<String, String>();
            defaultValues.put("bool", "false");
            defaultValues.put("byte", "0");
            defaultValues.put("bytes", "null");
            defaultValues.put("int8", "0");
            defaultValues.put("int16", "0");
            defaultValues.put("int32", "0");
            defaultValues.put("int64", "0");
            defaultValues.put("float32", ".0f");
            defaultValues.put("float64", ".0");
            defaultValues.put("string", "");
            defaultValues.put("datetime", "null");
        }

        @Override
        public void formatReference(Reference reference) {
            out.format("import %s.*;",
                    reference.target.replace('/', '.').toLowerCase());
            out.println();;
        }

        @Override
        public void formatConsts(ConstsDef def) {
            if (nativeTypes.containsKey(def.type)) {
                def.nativeType = nativeTypes.get(def.type);
            }
            else {
                return;
            }

            if (def.type == "string") {
                for (ConstsDef.Constant constant : def.getConstants())
                {
                    constant.value = "\"" + constant.value + "\"";
                }
            }

            indent(0); out.format("public final class %s {\n", def.name);
            indent();
            indent(0); out.format("private %s() { }\n", def.name);
            out.println();
            for (ConstsDef.Constant constant : def.getConstants()) {
                indent(0);
                out.format("public static final %s %s", def.nativeType, constant.name);
                if (!StringUtil.isNullOrEmpty(constant.value)) {
                    out.format(" = %s", constant.value);
                }
                out.println(';');
            }
            unindent();
            indent(0); out.println('}');
        }

        @Override
        public void formatCell(CellDef def) {
            def.baseClass = def.base;
            if (StringUtil.isNullOrEmpty(def.baseClass)) {
                def.baseClass = (def.isEvent() ? "Event" : "Cell");
            }
            indent(0); out.format("public class %s extends %s {\n",
                    def.name, def.baseClass);
            indent();
            indent(0); out.println("protected static Tag tag;");
            preprocessProperties(def);
            formatPropertyFields(def);
            formatProperties(def);
            formatMethods(def);
            unindent();
            indent(0); out.println('}');
        }

        private void formatPropertyFields(CellDef def) {
            if (def.hasProperties()) {
                out.println();
            }
            for (CellDef.Property prop : def.getProperties()) {
                indent(0); out.format("private %s %s;", prop.nativeType, prop.nativeName);
                out.println();
            }
        }

        private void formatProperties(CellDef def) {
            for (CellDef.Property prop : def.getProperties()) {
                out.println();
                indent(0); out.format("public %s get%s() {",
                        prop.nativeType, prop.name);
                out.println();
                indent(1); out.format("return %s;", prop.nativeName);
                out.println();
                indent(0); out.println("}");
                indent(0); out.format("public %s set%s(%s value) {",
                        def.name, prop.name, prop.nativeType);
                out.println();
                indent(1); out.format("%s = value;", prop.nativeName);
                out.println();
                indent(1); out.println("return this;");
                indent(0); out.println("}");
            }
        }

        private void formatMethods(CellDef def) {
            formatConstructor(def);
            formatInitializer(def);
            formatEqualsTo(def);
            formatHashCode(def);
            formatIsEquivalend(def);
            formatTypeAccessors(def);
            formatDescribe(def);

            out.println();
            indent(0); out.println("// Serialization");

            formatDeserialize(def);
            formatLength(def);
            formatSerialize(def);
        }

        private void formatConstructor(CellDef def) {
            out.println();
            indent(0); out.format("public %s() {", def.name);
            out.println();
            indent(1); out.println("init();");
            indent(0); out.println("}");
        }

        private void formatInitializer(CellDef def) {
            out.println();
            indent(0); out.println("private void init() {");
            for (CellDef.Property prop : def.getProperties()) {
                indent(1); out.format("%s = %s;", prop.nativeName, prop.defaultValue);
                out.println();
            }
            indent(0); out.println("}");
        }

        private void formatEqualsTo(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("protected boolean equalsTo(Cell other) {");
            indent(1); out.println("if (!super.equalsTo(other)) {");
            indent(2); out.println("return false;");
            indent(1); out.println("}");
            if (def.hasProperties()) {
                indent(1); out.format("%s o = (%s)other;", def.name, def.name);
                out.println();
                for (CellDef.Property prop : def.getProperties()) {
                    indent(1); out.format("if (%s != o.%s) {",
                            prop.nativeName, prop.nativeName);
                    out.println();
                    indent(2); out.println("return false;");
                    indent(1); out.println("}");
                }
            }
            indent(1); out.println("return true;");
            indent(0); out.println("}");
        }

        private void formatHashCode(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("public int hashCode(Fingerprint fingerprint) {");
            if (def.hasProperties()) {
                indent(1); out.println("Hash hash = new Hash(super.hashCode(fingerprint);");
                indent(1); out.println("Fingerprint.Capo touched = fingerprint.capo(tag.getOffset());");
                for (CellDef.Property prop : def.getProperties()) {
                    indent(1); out.format("if (touched.get(%d)) {", prop.index);
                    out.println();
                    indent(2); out.format("hash.update(%s);", prop.nativeName);
                    out.println();
                    indent(1); out.println("}");
                }
                indent(1); out.println("return hash.code();");
            } else {
                indent(1); out.println("return super.hashCode(fingerprint);");
            }
            indent(0); out.println("}");
        }

        private void formatIsEquivalend(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("protected boolean isEquivalent(Cell other) {");
            indent(1); out.println("if (!super.isEquivalent(other)) {");
            indent(2); out.println("return false;");
            indent(1); out.println("}");
            if (def.hasProperties()) {
                indent(1); out.format("%s o = (%s)other;", def.name, def.name);
                out.println();
                indent(1); out.println("Fingerprint.Capo touched = fingerprint.capo(tag.getOffset());");
                for (CellDef.Property prop : def.getProperties()) {
                    indent(1); out.format("if (touched.get(%d)) {", prop.index);
                    out.println();
                    indent(2); out.format("if (%s != o.%s) {", prop.nativeName, prop.nativeName);
                    out.println();
                    indent(3); out.println("return false;");
                    indent(2); out.println("}");
                    indent(1); out.println("}");
                }
            }
            indent(1); out.println("return true;");
            indent(0); out.println("}");
        }

        private void formatTypeAccessors(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.format("public %s tag() { return tag; }",
                (def.isEvent() ? "Cell.Tag" : "Tag"));
            out.println();
            if (def.isEvent()) {
                out.println();
                indent(0); out.println("@Override");
                indent(0); out.println("public int typeId() { return tag.");
            }
        }

        private void formatDescribe(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("protected void describe(StringBuilder sb) {");
            indent(1); out.println("super.describe(sb);");
            for (CellDef.Property prop : def.getProperties()) {
                indent(1); out.print("sb.append(\"");
                if (prop.index == 0) {
                    out.print(" ");
                } else {
                    out.print(", ");
                }
                out.print(prop.name);
                out.print(": \"");
                out.println(");");
                indent(1); out.print("sb.append(");
                out.print(prop.nativeName);
                out.println(");");
            }
            indent(0); out.println("}");
        }

        private void formatDeserialize(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("public void deserialize(Deserializer deserializer) {");
            indent(1); out.println("super.deserialize(deserializer);");
            if (def.hasProperties()) {
                indent(1); out.println("Fingerprint.Capo touched = fingerprint.capo(tag.getOffset());");
                for (CellDef.Property prop : def.getProperties()) {
                    indent(1); out.format("if (touched.get(%d)) {", prop.index);
                    out.println();
                    indent(2); out.format("%s = deserializer.%s;", prop.nativeName,
                            formatReadMethod(prop.typeSpec));
                    out.println();
                    indent(1); out.println("}");
                }
            }
            indent(0); out.println("}");
        }

        private void formatLength(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("public void length() {");
            indent(1); out.println("int length = super.length();");
            if (def.hasProperties()) {
                indent(1); out.println("Fingerprint.Capo touched = fingerprint.capo(tag.getOffset());");
                for (CellDef.Property prop : def.getProperties()) {
                    indent(1); out.format("if (touched.get(%d)) {", prop.index);
                    out.println();
                    indent(2); out.format("length += Serializer.%s(%s);",
                            formatLengthMethod(prop.typeSpec), prop.nativeName);
                    out.println();
                    indent(1); out.println("}");
                }
            }
            indent(1); out.println("return length;");
            indent(0); out.println("}");
        }

        private void formatSerialize(CellDef def) {
            out.println();
            indent(0); out.println("@Override");
            indent(0); out.println("public void serialize(Serializer serializer) {");
            indent(1); out.println("super.serialize(serializer);");
            if (def.hasProperties()) {
                indent(1); out.println("Fingerprint.Capo touched = fingerprint.capo(tag.getOffset());");
                for (CellDef.Property prop : def.getProperties()) {
                    indent(1); out.format("if (touched.get(%d)) {", prop.index);
                    out.println();
                    indent(2); out.format("serializer.%s(%s);",
                            formatWriteMethod(prop.typeSpec), prop.nativeName);
                    out.println();
                    indent(1); out.println("}");
                }
            }
            indent(0); out.println("}");
        }

        private static void preprocessProperties(CellDef def) {
            int index = 0;
            for (CellDef.Property prop : def.getProperties()) {
                prop.index = index++;

                prop.nativeName = StringUtil.firstToLower(prop.name) + "_";
                prop.name = StringUtil.firstToUpper(prop.name);

                if (Types.isPrimitive(prop.typeSpec.type)) {
                    if (StringUtil.isNullOrEmpty(prop.defaultValue)) {
                        prop.defaultValue = defaultValues.get(prop.typeSpec.type);
                    }
                    if (prop.typeSpec.type == "string") {
                        prop.defaultValue = "\"" + prop.defaultValue + "\"";
                    }
                }
                else {
                    prop.defaultValue = "null";
                }

                prop.nativeType = formatTypeSpec(prop.typeSpec);
            }
        }

        private static String formatTypeSpec(TypeSpec typeSpec) {
            String type = typeSpec.type;
            if (!Types.isBuiltin(type)) {
                return type;  // custom type
            }
            return Types.isPrimitive(type) ? nativeTypes.get(type)
                                           : formatCollectionType(typeSpec);
        }

        private static String formatCollectionType(TypeSpec typeSpec) {
            StringBuilder sb = new StringBuilder(nativeTypes.get(typeSpec.type));
            if (typeSpec.details != null) {
                sb.append('<');
                boolean leading = true;
                for (TypeSpec detail : typeSpec.details) {
                    if (leading) {
                        leading = false;
                    }
                    else {
                        sb.append(", ");
                    }
                    sb.append(formatTypeSpec(detail));
                }
                sb.append('>');
            }
            return sb.toString();
        }

        private static String formatReadMethod(TypeSpec typeSpec) {
            String type = typeSpec.type;
            if (!Types.isBuiltin(type)) {
                return String.format("readCell(%s.class)", type);
            }
            if (Types.isPrimitive(type)) {
                return String.format("read%s()", typeNames.get(type));
            }
            else {
                // collection type
                return "";
            }
        }

        private static String formatLengthMethod(TypeSpec typeSpec) {
            String type = typeSpec.type;
            if (!Types.isBuiltin(type)) {
                return "lengthCell";
            }
            if (Types.isPrimitive(type)) {
                return String.format("length%s", typeNames.get(type));
            }
            else {
                // collection type
                return "";
            }
        }

        private static String formatWriteMethod(TypeSpec typeSpec) {
            String type = typeSpec.type;
            if (!Types.isBuiltin(type)) {
                return "writeCell";
            }
            if (Types.isPrimitive(type)) {
                return String.format("write%s", typeNames.get(type));
            }
            else {
                // collection type
                return "";
            }
        }

        public void indent() {
            ++baseIndentation;
        }

        public void unindent() {
            --baseIndentation;
        }

        private void indent(int level) {
            for (int i = 0; i < (baseIndentation + level); ++i) {
                out.print(tab);
            }
        }
    }
}
